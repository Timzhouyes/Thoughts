---
layout:     post   				    # 使用的布局（不需要改）
title:     梳理TCP,HTTP,HTTPS,HTTP/2 				# 标题 
subtitle:   对一些面试之中可能考察的知识点做一点复习 #副标题
description: Try it now
date:       2019-03-21				# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - 学习
    - TCP
    - UDP
    - HTTP
    - HTTP/2
    - HTTPS
---
本文对于Web岗面试之中关于网络的各种问题进行了一点整理，欢迎大家讨论。
# 1. TCP
## 1.1 TCP的三次握手
转载至[TCP 三次握手四次挥手
](https://mp.weixin.qq.com/s/tGlWTrr5KLAv1AflfeAejA)

在我看来，TCP的各种机制设计都是因为网络报文传输的不确定性（延迟了， 丢包了,网线断了 etc），因此看似繁琐的报文重复传输和字段的重复包括（每一个都有ACK）是牺牲了部分的传输效率来保证其是一个可靠的文件传输协议。在看的时候处处感叹，真的是每一个步骤都考虑到了网络不稳定需要重传的状况。

又看到一段话：三次握手是满足”在不可靠信道上传输可靠信息“的最小值。很有趣。
### 1.1.1 为什么要三次握手
  三次握手是保证双方都知晓对方同意连接的最小次数。可以看成每个客户端都有一个flag标识对方是否同意连接，其一开始都是False。
  
  在客户端A发送SYN报文之时，两边的flag都是false,然后在其客户端B接收到报文之后，其会将SYN ACK 传输给客户端A ，在传输报文这一刻也还是两边的flag都是false， 然后在A收到报文时，客户端A上面对于客户端B的flag会变成True，此时客户端A发送ACK给客户端B，告诉B客户端A已经知道客户端B的SYN ACK，之后在B接受到ACK之后，B上面对于客户端A的flag会变成True。
  
  此时双方关于对方的状态都已经知晓，接下来开始传输数据，也标志着连接的建立。 **在以后的每一个包中都含有ACK字段**
### 1.1.2 如果没有第三次握手怎么样？会出现什么问题？
  本人对网络上面的“防止失效报文被Server端接收进而开启另一进程导致浪费”的说法不太赞同。下面是觉得合理的解释:
  
 每次在发送报文，无论是SYN报文还是ACK报文的时候，都会带上序列号，而其其实是这样的情况：
 
 Client给Server发送SYN X（X和Y是序列号），Server回复ACK X，SYN Y，此时只可以证明两边都知晓从Client端发送到Server端的信息可以以X开头，但是从Server端到Client端的信息双方并没有达成一致（因为Client没有回复），所以三次握手之中的ACK Y 才被需要。
 
 ## 1.2 TCP的四次挥手
 ### 1.2.1 TCP的四次挥手怎么实现？
 1. 首先Client端给Server端发送FIN ACK，Server回复ACK告知其已收到
 2. Server 端返回一个ACk，在此之后Client 不可以继续传输数据（因为已经传输结束）
 3. 在Server的close-wait之后，Server会发送FIN ACK回去给CLient，说明服务器端的内容已经传输完毕
 4. Client在收到Server的FIN ACK 之后，给Server返回ACK，此时进入TIME-WAIT状态，要等待2个MSL（Maximum Segment Lifetime）（报文最大生存时间）之后释放连接
 5. B收到ACK之后释放连接
  ### 1.2.2 为什么一定要等待最后的2MSL?
原因是
1. 防止第四次挥手（从Client到Server传输ACK的过程）没有被对方收到。如果没有被收到，那么Server端会发出重传FIN，等待一段时间是为了将这种情况处理好
2. 等待的这一段时间可以让所有本次传输的报文在网络之中消失，使得下一次的SYN不会与此次的报文重叠，从而重复打开本已经要关闭的连接
# 2.HTTP , HTTP2/和HTTPS
## 2.1 什么是HTTP？
HTTP是一种能够获取如 HTML 这样的网络资源的 protocol(通讯协议).

一份完整的Web文档通常是不同的子文档拼接成的，比如image图片从一个server拿取，广告从Ad server拿取等等。

TCP是HTTP的底层，而HTTP是诸如HTML，CSS，JavaScript的底层。HTTP是一个应用层协议，是承载内容资源的协议。

## 2.2 基于HTML的组件系统
直接看mozilla的[教程](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview#%E5%9F%BA%E4%BA%8EHTTP%E7%9A%84%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F)就OK。

教程将其分为了三个部分，一是Client，一是Proxy，一是Server。
### 2.2.1 Client
要展示一个完整的网页，Browser首先发送一个请求获取HTML页面文档。在获得文档之后，才会获取CSS脚本或者其他样式来做页面渲染，再去获取一些其他资源，比如图片和视频等等。在完成这些步骤之后，浏览器才会显示一个完整的网页。

这也就是为什么如果网络不好的话网页的内容也可以显示出来，但是图片或者视频或者样式显示不出来的原因：只执行了第一步。
### 2.2.2 Proxy
本来在Client和Server之间，HTTP消息会经过很多台机器。如果我们让一个机器作为转发实体，即将流量通过他们，就可以将其当作Proxy。Proxy可能会有下面的作用：
- 缓存（可以是公开的也可以是私有的，像浏览器的缓存）
- 过滤（像反病毒扫描，家长控制...）
- 负载均衡（让多个服务器服务不同的请求）
- 认证（对不同资源进行权限管理）
- 日志记录（允许存储历史信息）
### 2.2.3 Server
Server是用来提供资源的机器，其只是一个意义上的机器，并不一定是某个固定的实体。
## 2.3 HTTP的基本性质
### 2.3.1 无状态性
在同一个连接之中，两个执行成功的请求之间是没有关系的。这就造成了用户在几个页面之间无法实现有关联的跳转。为了解决这种情况，带给用户无缝的体验，我们使用HTTP Cookies来解决这个问题。

将HTTP的Cookies添加到头部当中，这样创建一个会话就可以请求共享相同的上下文信息，这样就可以达成一个相同状态的转换。

总的来说，HTTP是无状态的，但是使用Cookies可以创建有状态的会话。

**（具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。）**
## 2.4 HTTP2/
